Multiple essential programming practices were included in these projects to ensure code functionality along with security. The code implements strong input validation for handling null values and enforcing length restrictions which becomes visible through the contact and task classes where I verify string nullity and implement field length limits. I used unit testing through @Test annotations to confirm the constraints function correctly. The atomic ID generator for tasks protects data integrity by stopping duplicate ID generation. The system maintains security through its final taskID field which lacks setters to stop users from modifying created data. Software predictability becomes possible because of defensive programming techniques that prevent unexpected input behaviors. The analysis of user requirements led me to develop concrete implementation rules which matched the requirements. The specification requirements defined maximum field lengths (first name at 10 characters and task name at 20) which my code implemented through substring operations to handle excess input lengths. The system preserves data integrity through null checks which substitute "NULL" placeholders when information is absent. The test cases prove how I checked the requirements by verifying that first names beyond 10 characters get shortened correctly as well as the handling of null values. My ability to validate program behavior according to user expectations came from writing tests that duplicated the requirements. The software design emphasized encapsulation while maintaining data integrity and achieving system maintainability. Class members receive access control through private fields which I made accessible through public getters and setters. The task constructor performs all validation tasks for name and description during construction. A static atomic counter system manages task IDs to ensure each ID remains distinct throughout all instances. Update methods including updateTaskName perform searches while providing appropriate feedback for missing items. All classes use identical validation patterns (e.g. contact names and task descriptions) to improve code maintenance. Future developers can understand the reasoning behind the implementation through the commented documentation which explains design choices and constraints.



